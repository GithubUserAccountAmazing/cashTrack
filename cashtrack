#!/bin/bash 

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#---------------------------------------------------------------------------

# Requirements:
# signal-cli: https://github.com/AsamK/signal-cli
# sqlite3: $ apt install sqlite3
# dedicated VM highly recommended :)

# Make sure you have started the daemon in your start up scripts using
# declare -r USERNAME="+xxxxxxxxxxx"
# signal-cli -u "$USERNAME" daemon &> "/dev/null" &

#---------------------------------------------------------------------------

s="int64"
ms="string "
me="array ["
c="string \"contentType\""
f="string \"remoteId\""
v="variant"
l="string \"expiresInSeconds\""
intfc="org.asamk.Signal"
mmbr="MessageReceivedV2"
perA="EXAMPLE USER A" # Signal user names"
perB="EXAMPLE USER B"
Aphone=15555555555 # Signal user phone numbers
Bphone=15555555555

emoji=True #flag to turn off emoji numbers

# check if signalbot database exists; if it doesnt 
#then create new database table and append initilization line
if [ ! -f signalbot.db ]; then

	sqlite3 signalbot.db "CREATE TABLE IF NOT EXISTS cashtrack 
	(date TEXT, amount REAL, type TEXT, perA REAL, balanceA REAL, perB REAL, balanceB REAL, note TEXT);" ;

    	sqlite3 signalbot.db "INSERT INTO cashtrack (date, amount, type, perA, balanceA, perB, balanceB, note) 
	VALUES ('1/1/1999', '0.00', 'send', '$perA', '0.00', '$perB', '0.00', 'new db');" ;

fi

echo " --- cashtrack --- "

errorOut() {
	printf "%s\n" "$*" 1>&2
	[[ $1 == True ]] && printf "%s %s" "$2" "$3"
}

cashtrack() {

	cashTrackSend() {
		signal-cli --dbus send -m "$2" "$1"
		echo "MESSAGE OUT"
	}

	emo() {
		emojiarr=("💵" "💰" "💸" "🤑" "🤩" "👽" "🥰" "😮")
 		echo "${emojiarr[$(( RANDOM % ${#emojiarr[@]} ))]}"
	}

	emoNum() {

		local num=$1 ; local result="" ; local digit

		# Check if the input is negative and multiply by -1 if so, then add (-) to result
 		if (( $(echo "$num < 0" | bc -l) )); then

 			num=$(echo "$num * -1" | bc -l)
 			result="(-) "

 		else
			# else add (+) instead
 			result="(+) "

 		fi

		case $emoji in

			True) 	
  			# Loop through each digit of the input and append the corresponding emoji to the output
  			while [ ${#num} -gt 0 ]; do

    				digit="${num:0:1}"

    				case "$digit" in

					# replace '.' character with ' . ' for better formatting
      					".") result+=" . " ;;

					# Use a unicode variation selector' }️⃣ 'to make the digit an emoji
      					*) result+="${digit}️⃣}" ; result=${result%?} ;;
				esac

    				num="${num:1}"

  			done ;;
		       
			*) result="${result}$num" ;; esac	
		
		printf "$result"
	}

        updatePER() {
	
		local txemo=$1	

                # If the fifth argument is True, replace the brackets with emoji numbers
                if [[ $5 == True ]]; then
			txemo=${txemo#*[}; txemo=${txemo%]*}
			txemo=$(emoNum $txemo)
                        txemo=$(sed -e "s/\[\([^]]*\)\]/$txemo/g" <<< "$1")
                fi

                # Print a message with emoji and the arguments
                printf "$(emo) cashTrack updated! $(emo)\n\n"
                printf "$txemo\n\n$(emoNum $2) : New Balance\n\n"
                printf "$(emoNum $3) : Previous Balance\n\nnote:\n$4\n"

        }

	txRem() {

  		txmsg="$PER has removed the last entry!" 

		lastTx=$(sqlite3 signalbot.db "SELECT perA, balanceA, perB, balanceB 
		FROM cashtrack ORDER BY rowid DESC LIMIT 1;" ;)

        	IFS='|' read -r dbNameA dbAMNTa dbNameB dbAMNTb <<< "$lastTx" ;

        	if [[ "$dbNameA" == "$perA" ]]; then
                	last="$dbAMNTa"
                	olast="$dbAMNTb"
		else
                	last="$dbAMNTb"
                	olast="$dbAMNTa"
        	fi

		sqlite3 signalbot.db "DELETE FROM cashtrack WHERE rowid = (SELECT max(rowid) FROM cashtrack);" ;

                lastTx=$(sqlite3 signalbot.db "SELECT perA, balanceA, perB, balanceB 
		FROM cashtrack ORDER BY rowid DESC LIMIT 1;" ;)

                IFS='|' read -r dbNameA dbAMNTa dbNameB dbAMNTb <<< "$lastTx" ;

                if [[ "$dbNameA" == "$perA" ]]; then
                        new="$dbAMNTa"
                        onew="$dbAMNTb"
		else
                        new="$dbAMNTb"
                        onew="$dbAMNTa"
                fi

		# call a function with arguments
  		cashTrackSend "$1" "$(updatePER "$txmsg" "$new" "$last" "$msgNote" False)" 
 		wait; sleep 1 

		# call the same function again for the other user
 		cashTrackSend "$ophone" "$(updatePER "$txmsg" "$onew" "$olast" "$msgNote" False)" 
	}

	# Use case to assign PER and oPER names based on phone number creating tx
	case "$1" in 
		"+$Aphone") PER="$perA" ; oPER="$perB" ophone="+$Bphone" ;; 
		"+$Bphone") PER="$perB" ; oPER="$perA" ; ophone="+$Aphone" ;; 
		*) errorOut True "$1" "err 2" ; return ;; 
	esac

	[[ $2 == "XX" ]] && { txmsg="$PER removed the previous entry!"; txRem "+$1"; return; } ;

	# Use parameter expansion to remove commas, newlines and quotes from the third argument
	msgBody=${3//[$'\n",']/}

	# Use read to split msgBody into AMNT and msgNote by the first whitespace
	read AMNT msgNote <<< "$msgBody" ; 

	# Use a case statement to set OP, oOP, txType and txmsg based on the second argument
	case $2 in
		"R ") OP="+"; oOP="-"; txType="request"; txmsg="$PER has requested [$AMNT] from $oPER" ;;
		"S ") OP="-"; oOP="+"; txType="send"; txmsg="$PER has sent [$AMNT] to $oPER" ;;
		*) errorOut True "$1"; return ;;
	esac

	# Check if AMNT is a valid number, otherwise call errorOut
	[[ $AMNT =~ [0-9]+ ]] || errorOut True "$1"

	# Use printf and bc to format AMNT as a decimal number
	AMNT=$(printf %.3f $(bc <<< "$AMNT")) ; AMNT=${AMNT%0}

	lastTx=$(sqlite3 signalbot.db "SELECT perA, balanceA, perB, balanceB FROM cashtrack ORDER BY rowid DESC LIMIT 1;") 

	IFS='|' read -r dbNameA dbAMNTa dbNameB dbAMNTb <<< "$lastTx" ;

	wait

	if [[ "$dbNameA" == "$perA" ]]; then
		last="$dbAMNTa" ; olast="$dbAMNTb"
	else
		last="$dbAMNTb" ; olast="$dbAMNTa"
	fi

	new=$(echo "$last $OP $AMNT" | bc)
	onew=$(echo "$olast $oOP $AMNT" | bc)

	# Set td as date 
	td=$(date)
	
	# use SQL commands to insert the transaction data into a database table
	sql="INSERT INTO cashtrack (date, amount, type, perA, balanceA, perB, balanceB, note) 
	VALUES ('$td', '$AMNT', '$txType', '$PER', '$new', '$oPER', '$onew', '$msgNote')" ;

	sqlite3 signalbot.db "$sql"; wait

	#Use cashTrackSend and updatePER to send messages to both parties
	cashTrackSend "$1" "$(updatePER "$txmsg" "$new" "$last" "$msgNote" True)" ; wait; sleep 1
	cashTrackSend "$ophone" "$(updatePER "$txmsg" "$onew" "$olast" "$msgNote" True)" ; wait
}

examineMsg() {

	printf "TIME: %s\\nSENDER: %s\\nMSG: %b\\nCONTENT TYPE: %s\\nFILE NAME: %s\\n" "$@"

	# Check if the sender is a valid phone number, otherwise exit with an error
	[[ $2 != "+($Aphone|$Bphone)" ]] && { errorOut False; return; }
	
	signal-cli --dbus sendReceipt -t "$1" --type read "$2" ; wait
	signal-cli --dbus sendTyping "$2"

	# Extract the first two characters of the message body and convert them to uppercase
	tx="${3:0:2}" ; tx="${tx^^}"

	case $tx in
		R\ |S\ |XX) echo "cashtrack invoked" ; cashtrack "$2" "$tx" "${3:2}" ;; 
		*) errorOut True "$1" "Err #1: tx value of $tx" ;; 
	esac
}
# Update the global variables that store the message information by
# searching for the dbus substrings defined above. Then manipulate the strings.
readMsg() {

	# use a case statement to check which line of dbus output is being read
	case $1 in

		# set TIMESTAMP by removing the first 6 characters of 'int64' string
  		0) t="${2:6}" ;;

		# set SENDER by removing everything before and after the quotes
		1) a="${2#*\"}" ; a="${a%\"*}" ;;

		2) case "$2" in

			# set first line of MSG by removing the first 8 characters of $2 and adding a newline
			"$ms"*) b="${2:8}\n" ;;

			# if not the begining of the MSG-decrement j to skip this line
			*) j=$((j-1)) ;; esac ;;

		# if needed, used to add multiple lines to MSG
		3) case "$2" in

			# if "array [" is found, remove everything after the last quote from MSG
			"$me"*) b="${b%\"*}" ;;

			# otherwise, append the line to MSG and decrement j until "array [" is found
			*) b+="$2\n" && j=$((j-1)) ;; esac ;;

		# if needed, set CONTENT TYPE
		4) case "$d $2" in

			# if contentType is found and d is false, set d to true and decrement j
			"false $c"*) d=true && j=$((j-1)) ;;

			# if variant is found and d is true, set e to the value between quotes
			"true $v"*) e="${2#*\"}" ; e="${e%\"*}" ;;

			# otherwise, decrement j
			*) j=$((j-1)) ;; esac ;;

		# if needed, set FILE NAME
		5) case "$g $2" in

			# if remoteId is found and g is false, set g to true and decrement j
			"false $f"*) g=true && j=$((j-1)) ;;

			# if variant is found and g is true, set h to the value between quotes
			"true $v"*) h="${2#*\"}" ; h="${h%\"*}" ;;

			# otherwise, decrement j
			*) j=$((j-1)) ;; esac ;;

	# if expiresInSeconds is found, call examineMsg with the global variables as arguments
	esac; [[ "$2" == "$l"* ]] && examineMsg "$t" "$a" "$b" "$e" "$h"
}

# Clear the terminal screen and then run a dbus-monitor command that listens for
# new signal messages. Pipe the output to a while loop that reads each
# line of the dbus and pass it to the readMsg function.
clear
dbus-monitor --session "type='signal',interface='$intfc', member='$mmbr'" |
while read -r dbus; do
	# reset variables when new message starting with "int64" is received
	[[ "$dbus" == "$s"* ]] && { j=0; b=""; e=""; h=""; d=false; g=false; }
	readMsg $j "$dbus"
	((j++))
done
